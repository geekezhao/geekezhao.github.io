{"meta":{"title":"Geeke's Blog","subtitle":"","description":"","author":"Geek ZHAO","url":"https://zqzhao.cn","root":"/"},"pages":[],"posts":[{"title":"Construct","slug":"construct","date":"2020-04-05T03:41:10.000Z","updated":"2020-04-05T03:52:01.823Z","comments":true,"path":"2020/04/05/construct/","link":"","permalink":"https://zqzhao.cn/2020/04/05/construct/","excerpt":"","text":"Formative Construct and Reflective ConstructReading Materials: MISQ 1MacKenzie.pdf 2REVISITING_BIAS 3CRITICAL_IMPORTANCE 4NEGATIVE_CONSEQUENCES 5PLS-SEM Detmar Straub Speech notes","categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"}],"tags":[{"name":"Theorical_Basis","slug":"Theorical-Basis","permalink":"https://zqzhao.cn/tags/Theorical-Basis/"}]},{"title":"News Clustering by Title","slug":"news-clustering","date":"2018-03-13T04:13:06.000Z","updated":"2020-04-05T02:56:20.800Z","comments":true,"path":"2018/03/13/news-clustering/","link":"","permalink":"https://zqzhao.cn/2018/03/13/news-clustering/","excerpt":"","text":"##0. Thinking###0.1 Word List Selection Customed word list and divided into two layers by category, summed as final eigenvalues, if there are multiple eigenvalues in the same layer then averaged(although this leads to inaccurate classification, eigenvalues tend to be closer). First.txt Used to categorize the main categories, including philosophy, awards and conference activities, research, promotion Each category starts with a whole hundred and the remaining spaces are replaced by “/n” Using the dictionary sequence number *1000000 as an eigenvalue Second.txt Used to classify sub-categories, including faculties, national regions, international regions, international organizations Each category starts with a whole hundred and the remaining spaces are replaced by “/n” Using the dictionary serial number *1000 as an eigenvalue ###0.2 Adjustment in K-means When selecting equal spacing selection or random selection, the final result will lead to unevenness in some classes, so select the starting centroid according to a given list, the list has 10 elements, the selected k-value is less than or equal to 10, then selected in the list; the selected k-value is greater than 10, more than 10 parts of the overall medium spacing selection. 1list &#x3D; [50000000, 150000000, 250000000, 350000000, 450000000, 50000, 150000, 250000, 350000, 450000] ###0.3 Text Processing Use regular matching to remove punctuation after source text is entered The dictionary is re-ordered according to python’s built-in sort function, because we also need to find a feature word belongs to the original feature word class in reverse, so select the new dictionary, including both the feature word and the original serial number (dictionary’s subscript serial number expresses the current new serial number, the new serial number is easy to find half) ##1. Input ###1.1 Crawler First we crawled 3000+ news headlines on the home page of Zhejiang University. 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;from bs4 import BeautifulSoupimport requestssName &#x3D; &quot;new.txt&quot;f &#x3D; open(sName, &#39;w+&#39;)for i in range(1,188): url &#x3D; &quot;http:&#x2F;&#x2F;www.zju.edu.cn&#x2F;xw&#x2F;list&quot; + str(i) + &quot;.htm&quot; headers &#x3D; &#123; &#39;User-Agent&#39;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;59.0.3071.115 Safari&#x2F;537.36&quot;, &#125; r &#x3D; requests.get(url, headers&#x3D;headers) r.encoding&#x3D;&#39;utf-8&#39; demo &#x3D; r.text soup &#x3D; BeautifulSoup(demo,&#39;html.parser&#39;) # print(&quot;**********************&quot;) for result in soup.find_all(&quot;ul&quot;, &quot;news&quot;): m&#x3D;result.get_text() # print(m) f.write(m) print(url)f.close() ###1.2 Regularization Then regularize to get the title list - this step is relatively simple, just call the re module and leave the code alone here. (Actually, I realized I didn’t save this code…) ###1.3 Word ListWhen creating the word list, I chose to double match, that is, first assign a value to each title according to the main keyword, which is larger, and then delete the value according to the secondary keyword. Since the end is abstracted to digital clustering, this works relatively well. (Of course, the results weren’t actually that great.) ##2. Clustering Here I’ve been lazily using the previous participle algorithm… That algorithm is not very accurate. Of course, it has no effect on the small jobs… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;# 浙江大学新闻网的list进行相似度计算，并且进行k-means聚类import operatorimport reimport mathfrom decimal import getcontext# import comp_char from cnsortpath &#x3D; &#39;lib&#x2F;&#39;fp &#x3D; open(path + &#39;First.txt&#39;, encoding&#x3D;&#39;utf-8&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []new_list &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x) new_list.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()id &#x3D; 0dictionary &#x3D; []for element in copy: if element !&#x3D; &#39;&#39;: dictionary.append([]) dictionary[id].append(element) for ele in new_list: if ele &#x3D;&#x3D; element and len(dictionary[id]) &lt; 2: dictionary[id].append(new_list.index(ele)) id +&#x3D; 1# using new list to substitute original dictionary which contains lots of &#39;&#39; (it&#39;s hard to visualize.)id &#x3D; 0for element in dictionary: print(id, &quot; &quot;, element, end&#x3D;&quot; &#x2F; &quot;) print(&quot; &quot;, copy[id]) id +&#x3D; 1print(&quot;----------&quot;)path &#x3D; &#39;scrapy&#x2F;&#39;f &#x3D; open(path + &#39;ori_news.txt&#39;)ori &#x3D; f.readlines()# ori is the list with out any operationtext &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) text.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this program# ------------- upper is reading part including wordlist and text -------------index &#x3D; []for x in ori: index.append([])# ------------- upper is append a vacant list prepared to insert index -------------for str_input in text: str_input &#x3D; re.sub(r&#39;,&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;，&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\.&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;。&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;——&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;……&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;！&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;!&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\?&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;？&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;；&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39; &#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&#x2F;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;、&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&quot;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\&#39;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&lt;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&gt;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;《&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;》&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\(&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\)&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;（&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;）&#39;, &quot;&quot;, str_input) # change all the punctuation as blank, however, we may split falsely. # Words get around, the step can also split at wrong place, so, I do not fix this mistake.# ------------- upper is transforming part -------------temp_text &#x3D; -1for str_input in text: temp_text +&#x3D; 1 str_head &#x3D; 0 str_tail &#x3D; len(str_input) ptr &#x3D; 5 temp &#x3D; 0 # 当前处理字段起始位置 # result &#x3D; [] # ch_index &#x3D; [] exact_num &#x3D; 0 # we sort dictionary(the copy) in this program and each word has two characteristic number # using as index to look back on original dictionary while temp &lt; str_tail - 1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] # 当前处理字段 tail &#x3D; len(dictionary) - 1 head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(dictionary[half][0], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(dictionary[half][0], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.eq(dictionary[half][0], in_put): flag &#x3D; 1 temp +&#x3D; len(in_put) if tail !&#x3D; 11 and in_put !&#x3D; &quot;&quot;: try: exact_num &#x3D; dictionary[half][1] except: print(half) # print(&quot;exact_num &#x3D; &quot;,exact_num) index[temp_text].append(exact_num * 1000000) # index[temp_text].append(half) # 这个语句仅用于调试之后的Part A部分 break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input) - 1: # print(str_input[temp], end&#x3D;&#39;&#x2F;&#39;) # result.append(str_input[temp]) # ch_index.append(-1) temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1 # ------ Part A 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # for element in index[temp_text]: # print(element,end&#x3D;&quot; &quot;) # # print(dictionary[element]) # print(&quot;&quot;) # # print(index[temp_text]) # print(&quot;------------------------------&quot;) # ------ Part A END ------ if len(index[temp_text]) &gt; 1: sum &#x3D; 0 for element in index[temp_text]: sum +&#x3D; element average &#x3D; sum &#x2F; len(index[temp_text]) index[temp_text] &#x3D; [] index[temp_text].append(int(average)) # ------ Part B 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # print(index[temp_text]) # print(&quot;-------------&quot;) # ------ Part B END ------# ------------ Upper is first array for the title (the main class) ------------path &#x3D; &#39;lib&#x2F;&#39;fp &#x3D; open(path + &#39;Second.txt&#39;, encoding&#x3D;&#39;utf-8&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []new_list &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x) new_list.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()id &#x3D; 0dictionary &#x3D; []for element in copy: if element !&#x3D; &#39;&#39;: dictionary.append([]) dictionary[id].append(element) for ele in new_list: if ele &#x3D;&#x3D; element and len(dictionary[id]) &lt; 2: dictionary[id].append(new_list.index(ele)) id +&#x3D; 1# using new list to substitute original dictionary which contains lots of &#39;&#39; (it&#39;s hard to visualize.)id &#x3D; 0for element in dictionary: print(id, &quot; &quot;, element, end&#x3D;&quot; &#x2F; &quot;) print(&quot; &quot;, copy[id]) id +&#x3D; 1print(&quot;----------&quot;)# ------------- upper is reading part including the second wordlist -------------temp_text &#x3D; -1for str_input in text: temp_text +&#x3D; 1 # str_head &#x3D; 0 str_tail &#x3D; len(str_input) ptr &#x3D; 5 temp &#x3D; 0 # 当前处理字段起始位置 while temp &lt; str_tail - 1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] # 当前处理字段 tail &#x3D; len(dictionary) - 1 head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(dictionary[half][0], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(dictionary[half][0], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.eq(dictionary[half][0], in_put): flag &#x3D; 1 temp +&#x3D; len(in_put) if tail !&#x3D; 11 and in_put !&#x3D; &quot;&quot;: try: exact_num &#x3D; dictionary[half][1] except: print(half) index[temp_text].append(exact_num * 1000) # index[temp_text].append(half) # 这个语句仅用于调试之后的Part A部分 break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input) - 1: temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1 # ------ Part A 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # for element in index[temp_text]: # print(element,end&#x3D;&quot; &quot;) # # print(dictionary[element]) # print(&quot;&quot;) # # print(index[temp_text]) # print(&quot;------------------------------&quot;) # ------ Part A END ------ if len(index[temp_text]) &gt; 1: sum &#x3D; 0 for i in range(1, len(index[temp_text])): sum +&#x3D; index[temp_text][i] average &#x3D; sum &#x2F; len(index[temp_text]) average +&#x3D; index[temp_text][0] index[temp_text] &#x3D; [] index[temp_text].append(int(average)) # ------ Part B 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # print(index[temp_text]) # print(&quot;-------------&quot;) # ------ Part B END ------# ------------ Upper is second array for the title (the second class) ------------for element in index: if element &#x3D;&#x3D; []: element.append(0)# ------------ 如果仍然没有结果 那么用0替代这个分组 --------------list &#x3D; [50000000, 150000000, 250000000, 350000000, 450000000, 50000, 150000, 250000, 350000, 450000]# ------------ Start Clustering -------------getcontext().prec &#x3D; 4k &#x3D; int(input(&quot;please input k:\\n&quot;))new_ori_set &#x3D; [float(item[0]) for item in index]centroid &#x3D; []if k &lt;&#x3D; 10: for i in range(0,k-1): centroid.append(list[i])else: for element in list: centroid.append(element) step &#x3D; (len(new_ori_set) - 0) &#x2F; (k-10) # print(new_ori_set) temp &#x3D; 0 while temp &lt; len(new_ori_set): centroid.append(new_ori_set[math.trunc(temp)]) temp +&#x3D; stepprint(&quot;original centroids: &quot;, centroid, &quot;\\n&quot;)class_i &#x3D; [[] for i in range(len(centroid))]class_text &#x3D; [[] for i in range(len(centroid))]# class_i is the null class for k centroidflag &#x3D; 1number &#x3D; 0times &#x3D; 0# sign if k never change or this program runs more than 100 timeswhile flag &#x3D;&#x3D; 1 and times &lt; 100: number +&#x3D; 1 flag &#x3D; 0 times +&#x3D; 1 class_i &#x3D; [[] for i in range(len(centroid))] class_text &#x3D; [[] for i in range(len(centroid))] # class_i is the null class for k centroid for i in range(0, len(new_ori_set)): distance &#x3D; float(&quot;inf&quot;) centroid_in_choose &#x3D; 0 for j in range(0, len(centroid)): if abs(new_ori_set[i] - centroid[j]) &lt; distance: distance &#x3D; abs(new_ori_set[i] - centroid[j]) centroid_in_choose &#x3D; j class_i[centroid_in_choose].append(new_ori_set[i]) class_text[centroid_in_choose].append(i) # sort all the elements into proper class # ------------ 每次 Clustering 之后的结果输出 ------------ # print(&quot;after %sth cluster: &quot; % number, &quot;\\n&quot;) # print(&quot;centroid class&quot;) # for i in range(0, len(class_i)): # print(centroid[i], &#39; &#39;, class_i[i]) # # print(&quot;---------&quot;) # ------------ 每次 Clustering 之后的结果输出 END ------------ for i in range(0, len(class_i)): sum &#x3D; 0 for j in range(0, len(class_i[i])): sum +&#x3D; class_i[i][j] if sum !&#x3D; 0: new_centroid &#x3D; round(sum &#x2F; len(class_i[i]), 3) else: continue if new_centroid !&#x3D; centroid[i]: # print(&quot;change centroid &quot;, centroid[i], &quot;as &quot;, end&#x3D;&quot;&quot;) centroid[i] &#x3D; new_centroid # print(centroid[i]) flag &#x3D; 1 # print(&quot;---------&quot;) # change the wrong centroid# ------------ Clustering 最终结果输出 -----------# print(&quot;THE CONCLUSION IS：&quot;)# print(&quot;centroid class&quot;)# for i in range(0, len(class_i)):# print(centroid[i], &#39; &#39;, [text[element] for element in class_text[i]])# ------------ Clustering 最终结果输出 END -----------# -------------- * UPPER IS CLUSTERING, CLUSTERING IS END.* --------------# ------------ 输出到txt -------------try: path &#x3D; &#39;out&#x2F;&#39; f &#x3D; open(path + &quot;result.txt&quot;, &quot;w+&quot;) f.write(&quot;cat\\ttitle\\n&quot;) for i in range(0, len(class_i)): for element in class_text[i]: f.write(str(i) + &quot;\\t&quot; + text[element] + &quot;\\n&quot;) f.close() print(&quot;Print out %d classes successfully.&quot;%k)except: print(&quot;Print out to txt ERROR.&quot;)# ------------ 输出到txt END -------------","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]},{"title":"Chinese Characters Clustering","slug":"simple-clustering","date":"2018-01-25T08:47:26.000Z","updated":"2020-04-05T02:57:13.105Z","comments":true,"path":"2018/01/25/simple-clustering/","link":"","permalink":"https://zqzhao.cn/2018/01/25/simple-clustering/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;import reimport operatorblank &#x3D; [chr(183)]tabs &#x3D; [&#39;&#39;]def tree(lst): l &#x3D; len(lst) if l &#x3D;&#x3D; 0: print(&#39;─&#39; * 3) else: for i, j in enumerate(lst): if i !&#x3D; 0: print(tabs[0], end&#x3D;&#39;&#39;) if l &#x3D;&#x3D; 1: s &#x3D; &#39;─&#39; * 3 elif i &#x3D;&#x3D; 0: s &#x3D; &#39;┬&#39; + &#39;─&#39; * 2 elif i + 1 &#x3D;&#x3D; l: s &#x3D; &#39;└&#39; + &#39;─&#39; * 2 else: s &#x3D; &#39;├&#39; + &#39;─&#39; * 2 print(s, end&#x3D;&#39;&#39;) if isinstance(j, list) or isinstance(j, tuple): if i + 1 &#x3D;&#x3D; l: tabs[0] +&#x3D; blank[0] * 3 else: tabs[0] +&#x3D; &#39;│&#39; + blank[0] * 2 tree(j) else: print(&quot; &quot;, j) tabs[0] &#x3D; tabs[0][:-3]def judge_element_delete(list_input, centroid, group, match_num): for list_element in list_input: if isinstance(list_element, list): for element in list_element: if element &#x3D;&#x3D; match_num: del centroid[list_input.index(list_element)] del group[list_input.index(list_element)] else: if list_element &#x3D;&#x3D; match_num: del centroid[list_input.index(list_element)] del group[list_input.index(list_element)]# --------------- in this part we save the list as list ---------------path &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;desktop&#x2F;&#39;fp &#x3D; open(path + &#39;list.txt&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()# --------------- this part end ---------------# in this part we know the average length in this list is 2, thus we set step as 5.# In that case, we can contain at least one word.# totally, there are 56064 words in this list and only 56 is longer than 5.# In that case, 5 can be a reasonable step for this program.# sum &#x3D; 0# num &#x3D; 0# for x in copy:# sum +&#x3D; len(x)# num +&#x3D; 1# average &#x3D; (int)(sum&#x2F;num)# print(average, &#39; &#39;, num);# max_lenth &#x3D; 0# for x in copy:# if max_lenth &lt; len(x):# max_lenth &#x3D; len(x)## print(max_lenth)# number &#x3D; 0# for x in copy:# if len(x) &gt; 5:# number +&#x3D; 1## print(number)# --------------- the upper is the calculation in the preparation ---------------str_input &#x3D; input(&quot;请输入一个段落：\\n&quot;)str_input &#x3D; re.sub(r&#39;,&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;，&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;\\.&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;。&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;——&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;……&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;！&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;!&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;\\?&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;？&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;;&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;；&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39; &#39;, &quot;&quot;, str_input)# change all the punctuation as blank, however, we may split falsely.# Words get around, the step can also split at wrong place, so, I do not fix this mistake.str_head &#x3D; 0str_tail &#x3D; len(str_input)ptr &#x3D; 5temp &#x3D; 0step &#x3D; 5result &#x3D; []ch_index &#x3D; []while temp &lt; str_tail-1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] tail &#x3D; len(copy) head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(copy[half], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(copy[half], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) else: # print(in_put, end&#x3D;&#39;&#x2F;&#39;) result.append(in_put) ch_index.append(half) flag &#x3D; 1 temp +&#x3D; len(in_put) break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input)-1: # print(str_input[temp], end&#x3D;&#39;&#x2F;&#39;) result.append(str_input[temp]) ch_index.append(-1) temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1group &#x3D; resultcentroid &#x3D; ch_index# group &#x3D; input(&quot;Please input some numbers spit as blank:\\n&quot;).split(&quot; &quot;)# group_num &#x3D; len(group)# for element in group:# centroid.append(int(element))precision &#x3D; 0for element in group: precision &#x3D; len(element) if len(element) &gt; precision else precisiongroup_num &#x3D; len(group)while group_num !&#x3D; 2: # print(&quot;the numbers of groups now is &quot;, group_num, &quot;\\n&quot;) matrix &#x3D; [[] for i in range(group_num)] for i in range(group_num): for j in range(group_num): distance &#x3D; abs(int(centroid[i]) - int(centroid[j])) matrix[i].append(distance) # --------------- matrix --------------- # print(&quot;distance matrix :&quot;) # for i in range(group_num): # print(matrix[i]) # matrix contains the distance between every two elements # print(&quot;------------&quot;) max_in_matrix &#x3D; 0 for i in range(group_num): for j in range(group_num): max_in_matrix &#x3D; max_in_matrix if max_in_matrix &gt; matrix[i][j] else matrix[i][j] # print(max_in_matrix) # if max_in_matrix &#x3D;&#x3D; 0: # break for i in range(group_num): for j in range(group_num): matrix[i][j] &#x2F;&#x3D; max_in_matrix matrix[i][j] &#x3D; round(1 - matrix[i][j], precision) if round(1 - matrix[i][j], precision) !&#x3D; 1 else 0 # print(&quot;standard matrix :&quot;) # for i in range(group_num): # print(matrix[i]) # print(&quot;------------&quot;) # standard the matrix similarity &#x3D; 0 for i in range(group_num): for j in range(group_num): similarity &#x3D; similarity if similarity &gt; matrix[i][j] else matrix[i][j] # print(&quot;max similarity in the matrix: &quot;, max_in_matrix, &quot;\\n&quot;) # --------------- matrix --------------- # find the max similarity in this matrix temp_class &#x3D; [] index &#x3D; [] flag &#x3D; 0 for i in range(group_num): for j in range(group_num): if matrix[i][j] &#x3D;&#x3D; similarity: index.append(i) index.append(j) flag &#x3D; 1 temp_class.append(group[i]) temp_class.append(group[j]) if flag &#x3D;&#x3D; 1: break if flag &#x3D;&#x3D; 1: break # find the first center index of new group group_num &#x3D; len(group) for i in range(group_num): if matrix[index[0]][i] &#x3D;&#x3D; similarity and i !&#x3D; index[1]: temp_class.append(group[i]) index.append(i) for i in range(group_num): if matrix[index[1]][i] &#x3D;&#x3D; similarity and i !&#x3D; index[0]: temp_class.append(group[i]) index.append(i) new_centroid &#x3D; 0 for element in index: new_centroid +&#x3D; centroid[element] new_centroid &#x2F;&#x3D; len(index) for element in index: group[element] &#x3D; &#39;substitute&#39; centroid[element] &#x3D; &#39;substitute&#39; lenth &#x3D; len(group) temp_flag &#x3D; 0 while temp_flag !&#x3D; 1: temp_flag &#x3D; 1 for i in range(0, lenth): if group[i] &#x3D;&#x3D; &#39;substitute&#39;: del group[i] lenth &#x3D; len(group) temp_flag &#x3D; 0 break lenth &#x3D; len(centroid) temp_flag &#x3D; 0 while temp_flag !&#x3D; 1: temp_flag &#x3D; 1 for i in range(0, lenth): if centroid[i] &#x3D;&#x3D; &#39;substitute&#39;: del centroid[i] lenth &#x3D; len(centroid) temp_flag &#x3D; 0 break group.append(temp_class) centroid.append(new_centroid) group_num &#x3D; len(group)print(group)tree(group)","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]},{"title":"Python 3.5 Set-Up","slug":"python-setting","date":"2017-11-16T08:13:09.000Z","updated":"2020-04-05T02:57:11.158Z","comments":true,"path":"2017/11/16/python-setting/","link":"","permalink":"https://zqzhao.cn/2017/11/16/python-setting/","excerpt":"","text":"install Homebrew 1&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot; Jump if already installed. It’s necessary to update your homebrew to the latest version. Use Homebrew install Python3 &amp; pip3 (pip is a package management tool for Python), automatically latest version, you may choose another version. 1$ brew install python3 We use pip3 because we want to use Python 3.x.x. If you need pip simply, try 1$ sudo easy_install pip install pip need administrator role Check the version 1234$python --version$python3 --version$pip --version$pip3 --version Install [PyCharm](https://www.jetbrains.com/pycharm/). I recommend community edition. If you want the professional edition, there is a Free JetBrains Products License Server. Install additional packages: For example, bs4 (BeautifulSoup 4): PyCharm offer you an inner package management tool: Preferences –&gt; Project –&gt; Project Interpreter Click “+” to install packages you need. Usually there are some errors, follow its introduction and try again. At most cases, error occurs when you revoke the administrator role. So… sudoplease Another way is to install in the terminal: $ pip3 install bs4 if any problems, follow the introduction and try again. Usually you need to upgrade your “pip” “homebrew” “python” or other relative package.","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[]}],"categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"},{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Theorical_Basis","slug":"Theorical-Basis","permalink":"https://zqzhao.cn/tags/Theorical-Basis/"},{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]}