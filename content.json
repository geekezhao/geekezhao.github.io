{"meta":{"title":"Geeke's Blog","subtitle":"","description":"","author":"Geek ZHAO","url":"https://zqzhao.cn","root":"/"},"pages":[{"title":"categories","date":"2020-04-05T08:31:30.000Z","updated":"2020-04-05T08:32:35.155Z","comments":false,"path":"categories/index.html","permalink":"https://zqzhao.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"NK-model","slug":"nk-model","date":"2020-04-17T12:47:35.000Z","updated":"2020-04-17T18:41:53.366Z","comments":true,"path":"2020/04/17/nk-model/","link":"","permalink":"https://zqzhao.cn/2020/04/17/nk-model/","excerpt":"","text":"McCarthy, I. P., &amp; Tan, Y. K. (2000). Manufacturing competitiveness and fitness landscape theory. Journal of Materials Processing Technology, 107(1-3), 347-352. Esteve Almirall, Ramon Casadesus-Masanell. (2010). Open Versus Closed Innovation: A Model of Discovery and Divergence. Academy of Management Review, Vol. 35, No. 1, 27–47. Sina Blog: 研究工具 - NK MODEL 本文参考了上述材料以及人大经管论坛，现简要陈述NK MODEL如下。非常凑巧的是，这篇博客中的引文是AMR的这篇，正好是本周管理系统模块的选读论文。因此作为NK MODEL的入门文章，应当以此举例。 Link between NK-Model and FLTNK Model脱胎于Fitness Landscape Theory。 What is Fitness Landscape Theory? Fitness Landscape Theory类似于生态学中生态位的概念 对于某一物种而言，不同资源组合会形成适应度不同的环境 在诸多环境中，有几种bundle会特别适合这一物种，称为生态位（此处可以参考经济学中“预算束”的概念） 以资源建立空间坐标系（若有k个资源，即有k维空间），适应度在这一空间内应当形成类似于GMM图像的分布，即Fitness Landscape NK模型研究适用于处理系统内部要素的相互作用关系对系统的整体适应性的问题。由于系统存在复杂性，实证研究无法直接研究各要素间的相互关系以及各要素对系统整体的影响，此时NK模型提供一个间接、简洁、有效的手段对系统进行仿真。 NK模型的理解可以遵循基因型与表型的对应理解。（Kauffman）对应到上述Fitness Landscape Theory，基因型（genotype）的不同组合在此处对应着Fitness Landscape Theory中对资源的不同组合，表型（phenotype）的不同组合在此处对应系统最终的状态。系统的进化，或者说最优解，其实就是生物进化中的最终形态（在自然选择中当前总是保持最适）。NK MODEL本质上是一个进化算法。 基因之间存在交互作用，改变一个基因型并不意味着改变了单一表型而是对整体产生了影响，甚至影响的正面负面也会受到其他基因的调控。这种条件之间的Trade-off即NK模型的研究中心。 NK-Model NK-Model将复杂系统描述为一个由N个元素构成的系统，其中每个元素i都有各自的等位基因。例如$A_i=3$即为第i个元素有3个等位基因。现在我们为每个元素，从其等位基因集合中选出一个基因，则有Feature Vector$$，那么这个Vector即通过限定特征对应了某一System。 在(Almirall, Casadesus-Masanell, 2010)中，将一个完整的System（在文中Syestem即某一Product）均分为2 Subsystem，所以有$&lt;\\alpha, \\beta&gt; = = $。 至此已经解释了NK模型中“N”的含义，最后为“N”Part作结，我们引入系统的设计空间的概念。系统的设计空间（Design Space）即由N个feature组成的N维概率空间。空间的具体大小为$\\Pi_{i=1}^{N}A_i$，也就是组合数。 在(Almirall, Casadesus-Masanell, 2010)中，为了计算方便起见，每个Feature仅有2个等位基因，即设计空间大小为$2^N$。 现在我们要解释K的作用。K衡量的是元素间的interaction，即该系统中每个元素i都与k个其他元素进行交互，即系统复杂度。 在(Almirall, Casadesus-Masanell, 2010)中，对这一部分的描述原文摘录如下： There are $2^N$ possible product configurations. The contribution $c_i$ of each product feature $s_i$ to willingness to pay dependents on other K components. For each of $2^K$ possible combinations, a value is drawn from a uniform probability distribution on [0, 1]. The overall willingness to pay associated with $$ is the average over the N value contributions, WTP(s_1, s_2, ..., s_N) = \\dfrac{\\sum_{i=1}^{N}c_i(s_i; s_{i_1}, s_{i_2}, ..., s_{s_k})}{N}Where $s_{i_j}$, $j=\\{1, …, k\\}$ are the configurations of the K features with which $s_i$ interacts. We assume random assignment of dependencies($i_j$ are determined randomly in the model). 文章的细节还没看完有待补充，NK模型已经解释完毕。","categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"}],"tags":[{"name":"Theorical_Basis","slug":"Theorical-Basis","permalink":"https://zqzhao.cn/tags/Theorical-Basis/"}]},{"title":"MISQ Research Curation on IS Use","slug":"Burton-summary","date":"2020-04-05T08:28:07.000Z","updated":"2020-04-17T12:48:09.012Z","comments":true,"path":"2020/04/05/Burton-summary/","link":"","permalink":"https://zqzhao.cn/2020/04/05/Burton-summary/","excerpt":"","text":"Burton-Jones, A., Stein, M., Mishra, A. “IS Use,” in MIS Quarterly Research Curations, Ashley Bush and Arun Rai, Eds., http://misq.org/research-curations, December 1, 2017.MIS Quarterly Articles on IS Use Files here. This article is primarily an overview of the research content and the research methods used in IS use related article. Now, I’ll briefly summarize the article and give my comments. Focus of the Research CurationThis part introduce how they retrieve the previous article and determine the rim of dataset, actually “Paper Set” here. The standards is full of manipulation. The main procedure is shown as follow: Segment all the article based on the publish year: 1977-1999, 2000- Determine the search term also based on the publish year Exclude articles focused PURELY on users’ intentions, attitudes, behaviors etc. Exclude articles focused on misuse, abuse and addiction. The author also mention that they include or exclude an article based on their “collective judgement”. Progression of Research in MISQThis part summarize the revolutionary change and evolutionary change in IS use. One steady topic is the importance and the complexity of the IS use. This theme gradually develops since 1977 and still thrive nowadays. However, the sophistication in term measurement and theoretical basis allow researchers to discuss an old terminology in new context. (The article refer to which as the theoretical and empirical research.) “They can account for it with theories and methods that are sensitive to longitudinal, multilevel, and multifactorial contexts rather than reducing the reality of IS use into cross-sectional, single-level, and single-theory thinking.” About 2000, a novel branch of IS acceptance appears, which is due to the broken burble economy of Internet. I think it also devotes to the separation of the publish period. Thematic Advances in KnowledgeFour major thematic advances are mentioned here. Application, refinement, and integrations of various social psychological explanations of It acceptance. Development of theories to account for the dynamics of use. Richer measurement and methodological approaches Continuing expansion of the broader network of constructs. My CommentsWhen looking into the appendix, we find out that in early age of IT use, most of researchers use conceptual framework or qualitative methods while in later period they turn to quantitative methods. My question is : Could the quantitative methods help to clarify or refine the concepts? If so, how? Quantitative methods rely on theoretical basis to consolidate its validity, how can they help to refine the concept? Will the concept or the definition of IT use augment in future? If so, we still need to focus on qualitative methods. Mixed methods research gains its popularity in recent years. What is the exact definition mixed methods research? A SEM combines both qualitative data and quantitative data? Or a three-stage research including qualitative case helps refining the framework and a quantitative method validate the hypothesis?","categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"}],"tags":[{"name":"MIS_thinking","slug":"MIS-thinking","permalink":"https://zqzhao.cn/tags/MIS-thinking/"}]},{"title":"Formative Construct and Reflective Construct","slug":"construct","date":"2020-04-05T03:41:10.000Z","updated":"2020-04-17T12:48:03.670Z","comments":true,"path":"2020/04/05/construct/","link":"","permalink":"https://zqzhao.cn/2020/04/05/construct/","excerpt":"","text":"Reading Materials: MISQ 1MacKenzie.pdf 2REVISITING_BIAS 3CRITICAL_IMPORTANCE 4NEGATIVE_CONSEQUENCES 5PLS-SEM Detmar Straub Speech notes","categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"}],"tags":[{"name":"Theorical_Basis","slug":"Theorical-Basis","permalink":"https://zqzhao.cn/tags/Theorical-Basis/"}]},{"title":"GMM","slug":"GMM","date":"2020-03-31T04:02:31.000Z","updated":"2020-04-05T08:39:14.272Z","comments":true,"path":"2020/03/31/GMM/","link":"","permalink":"https://zqzhao.cn/2020/03/31/GMM/","excerpt":"","text":"","categories":[],"tags":[{"name":"CS_Math","slug":"CS-Math","permalink":"https://zqzhao.cn/tags/CS-Math/"}]},{"title":"SVD","slug":"SVD","date":"2020-03-18T10:05:32.000Z","updated":"2020-04-05T08:39:23.078Z","comments":true,"path":"2020/03/18/SVD/","link":"","permalink":"https://zqzhao.cn/2020/03/18/SVD/","excerpt":"","text":"","categories":[],"tags":[{"name":"CS_Math","slug":"CS-Math","permalink":"https://zqzhao.cn/tags/CS-Math/"}]},{"title":"News Clustering by Title","slug":"news-clustering","date":"2018-03-13T04:13:06.000Z","updated":"2020-04-05T09:14:15.721Z","comments":true,"path":"2018/03/13/news-clustering/","link":"","permalink":"https://zqzhao.cn/2018/03/13/news-clustering/","excerpt":"","text":"0. Thinking0.1 Word List SelectionCustom word list and divid into two layers by category, summed as final eigenvalues, if there are multiple eigenvalues in the same layer then averaged(although this leads to inaccurate classification, eigenvalues tend to be closer). First.txt Used to categorize the main categories, including philosophy, awards and conference activities, research, promotion Each category starts with a whole hundred and the remaining spaces are replaced by “/n” Using the dictionary sequence number *1000000 as an eigenvalue Second.txt Used to classify sub-categories, including faculties, national regions, international regions, international organizations Each category starts with a whole hundred and the remaining spaces are replaced by “/n” Using the dictionary serial number *1000 as an eigenvalue 0.2 Adjustment in K-meansWhen selecting equal spacing selection or random selection, the final result will lead to unevenness in some classes, so select the starting centroid according to a given list, the list has 10 elements, the selected k-value is less than or equal to 10, then selected in the list; the selected k-value is greater than 10, more than 10 parts of the overall medium spacing selection. 1list &#x3D; [50000000, 150000000, 250000000, 350000000, 450000000, 50000, 150000, 250000, 350000, 450000] 0.3 Text Processing Use regular matching to remove punctuation after source text is entered The dictionary is re-ordered according to python’s built-in sort function, because we also need to find a feature word belongs to the original feature word class in reverse, so select the new dictionary, including both the feature word and the original serial number (dictionary’s subscript serial number expresses the current new serial number, the new serial number is easy to find half) 1. Input1.1 CrawlerFirst we crawled 3000+ news headlines on the home page of Zhejiang University. 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;from bs4 import BeautifulSoupimport requestssName &#x3D; &quot;new.txt&quot;f &#x3D; open(sName, &#39;w+&#39;)for i in range(1,188): url &#x3D; &quot;http:&#x2F;&#x2F;www.zju.edu.cn&#x2F;xw&#x2F;list&quot; + str(i) + &quot;.htm&quot; headers &#x3D; &#123; &#39;User-Agent&#39;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;59.0.3071.115 Safari&#x2F;537.36&quot;, &#125; r &#x3D; requests.get(url, headers&#x3D;headers) r.encoding&#x3D;&#39;utf-8&#39; demo &#x3D; r.text soup &#x3D; BeautifulSoup(demo,&#39;html.parser&#39;) # print(&quot;**********************&quot;) for result in soup.find_all(&quot;ul&quot;, &quot;news&quot;): m&#x3D;result.get_text() # print(m) f.write(m) print(url)f.close() 1.2 RegularizationThen regularize to get the title list - this step is relatively simple, just call the re module and leave the code alone here. (Actually, I realized I didn’t save this code…) 1.3 Word ListWhen creating the word list, I chose to double match, that is, first assign a value to each title according to the main keyword, which is larger, and then delete the value according to the secondary keyword. Since the end is abstracted to digital clustering, this works relatively well. (Of course, the results weren’t actually that great.) 2. ClusteringHere I’ve been lazily using the previous participle algorithm… That algorithm is not very accurate. Of course, it has no effect on the small jobs… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;# 浙江大学新闻网的list进行相似度计算，并且进行k-means聚类import operatorimport reimport mathfrom decimal import getcontext# import comp_char from cnsortpath &#x3D; &#39;lib&#x2F;&#39;fp &#x3D; open(path + &#39;First.txt&#39;, encoding&#x3D;&#39;utf-8&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []new_list &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x) new_list.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()id &#x3D; 0dictionary &#x3D; []for element in copy: if element !&#x3D; &#39;&#39;: dictionary.append([]) dictionary[id].append(element) for ele in new_list: if ele &#x3D;&#x3D; element and len(dictionary[id]) &lt; 2: dictionary[id].append(new_list.index(ele)) id +&#x3D; 1# using new list to substitute original dictionary which contains lots of &#39;&#39; (it&#39;s hard to visualize.)id &#x3D; 0for element in dictionary: print(id, &quot; &quot;, element, end&#x3D;&quot; &#x2F; &quot;) print(&quot; &quot;, copy[id]) id +&#x3D; 1print(&quot;----------&quot;)path &#x3D; &#39;scrapy&#x2F;&#39;f &#x3D; open(path + &#39;ori_news.txt&#39;)ori &#x3D; f.readlines()# ori is the list with out any operationtext &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) text.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this program# ------------- upper is reading part including wordlist and text -------------index &#x3D; []for x in ori: index.append([])# ------------- upper is append a vacant list prepared to insert index -------------for str_input in text: str_input &#x3D; re.sub(r&#39;,&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;，&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\.&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;。&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;——&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;……&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;！&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;!&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\?&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;？&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;；&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39; &#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&#x2F;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;、&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&quot;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\&#39;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&lt;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;&gt;&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;《&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;》&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\(&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;\\)&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;（&#39;, &quot;&quot;, str_input) str_input &#x3D; re.sub(r&#39;）&#39;, &quot;&quot;, str_input) # change all the punctuation as blank, however, we may split falsely. # Words get around, the step can also split at wrong place, so, I do not fix this mistake.# ------------- upper is transforming part -------------temp_text &#x3D; -1for str_input in text: temp_text +&#x3D; 1 str_head &#x3D; 0 str_tail &#x3D; len(str_input) ptr &#x3D; 5 temp &#x3D; 0 # 当前处理字段起始位置 # result &#x3D; [] # ch_index &#x3D; [] exact_num &#x3D; 0 # we sort dictionary(the copy) in this program and each word has two characteristic number # using as index to look back on original dictionary while temp &lt; str_tail - 1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] # 当前处理字段 tail &#x3D; len(dictionary) - 1 head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(dictionary[half][0], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(dictionary[half][0], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.eq(dictionary[half][0], in_put): flag &#x3D; 1 temp +&#x3D; len(in_put) if tail !&#x3D; 11 and in_put !&#x3D; &quot;&quot;: try: exact_num &#x3D; dictionary[half][1] except: print(half) # print(&quot;exact_num &#x3D; &quot;,exact_num) index[temp_text].append(exact_num * 1000000) # index[temp_text].append(half) # 这个语句仅用于调试之后的Part A部分 break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input) - 1: # print(str_input[temp], end&#x3D;&#39;&#x2F;&#39;) # result.append(str_input[temp]) # ch_index.append(-1) temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1 # ------ Part A 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # for element in index[temp_text]: # print(element,end&#x3D;&quot; &quot;) # # print(dictionary[element]) # print(&quot;&quot;) # # print(index[temp_text]) # print(&quot;------------------------------&quot;) # ------ Part A END ------ if len(index[temp_text]) &gt; 1: sum &#x3D; 0 for element in index[temp_text]: sum +&#x3D; element average &#x3D; sum &#x2F; len(index[temp_text]) index[temp_text] &#x3D; [] index[temp_text].append(int(average)) # ------ Part B 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # print(index[temp_text]) # print(&quot;-------------&quot;) # ------ Part B END ------# ------------ Upper is first array for the title (the main class) ------------path &#x3D; &#39;lib&#x2F;&#39;fp &#x3D; open(path + &#39;Second.txt&#39;, encoding&#x3D;&#39;utf-8&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []new_list &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x) new_list.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()id &#x3D; 0dictionary &#x3D; []for element in copy: if element !&#x3D; &#39;&#39;: dictionary.append([]) dictionary[id].append(element) for ele in new_list: if ele &#x3D;&#x3D; element and len(dictionary[id]) &lt; 2: dictionary[id].append(new_list.index(ele)) id +&#x3D; 1# using new list to substitute original dictionary which contains lots of &#39;&#39; (it&#39;s hard to visualize.)id &#x3D; 0for element in dictionary: print(id, &quot; &quot;, element, end&#x3D;&quot; &#x2F; &quot;) print(&quot; &quot;, copy[id]) id +&#x3D; 1print(&quot;----------&quot;)# ------------- upper is reading part including the second wordlist -------------temp_text &#x3D; -1for str_input in text: temp_text +&#x3D; 1 # str_head &#x3D; 0 str_tail &#x3D; len(str_input) ptr &#x3D; 5 temp &#x3D; 0 # 当前处理字段起始位置 while temp &lt; str_tail - 1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] # 当前处理字段 tail &#x3D; len(dictionary) - 1 head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(dictionary[half][0], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(dictionary[half][0], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.eq(dictionary[half][0], in_put): flag &#x3D; 1 temp +&#x3D; len(in_put) if tail !&#x3D; 11 and in_put !&#x3D; &quot;&quot;: try: exact_num &#x3D; dictionary[half][1] except: print(half) index[temp_text].append(exact_num * 1000) # index[temp_text].append(half) # 这个语句仅用于调试之后的Part A部分 break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input) - 1: temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1 # ------ Part A 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # for element in index[temp_text]: # print(element,end&#x3D;&quot; &quot;) # # print(dictionary[element]) # print(&quot;&quot;) # # print(index[temp_text]) # print(&quot;------------------------------&quot;) # ------ Part A END ------ if len(index[temp_text]) &gt; 1: sum &#x3D; 0 for i in range(1, len(index[temp_text])): sum +&#x3D; index[temp_text][i] average &#x3D; sum &#x2F; len(index[temp_text]) average +&#x3D; index[temp_text][0] index[temp_text] &#x3D; [] index[temp_text].append(int(average)) # ------ Part B 仅用于调试变量 具体用于探测特征变量 ------ # print(text[temp_text]) # print(index[temp_text]) # print(&quot;-------------&quot;) # ------ Part B END ------# ------------ Upper is second array for the title (the second class) ------------for element in index: if element &#x3D;&#x3D; []: element.append(0)# ------------ 如果仍然没有结果 那么用0替代这个分组 --------------list &#x3D; [50000000, 150000000, 250000000, 350000000, 450000000, 50000, 150000, 250000, 350000, 450000]# ------------ Start Clustering -------------getcontext().prec &#x3D; 4k &#x3D; int(input(&quot;please input k:\\n&quot;))new_ori_set &#x3D; [float(item[0]) for item in index]centroid &#x3D; []if k &lt;&#x3D; 10: for i in range(0,k-1): centroid.append(list[i])else: for element in list: centroid.append(element) step &#x3D; (len(new_ori_set) - 0) &#x2F; (k-10) # print(new_ori_set) temp &#x3D; 0 while temp &lt; len(new_ori_set): centroid.append(new_ori_set[math.trunc(temp)]) temp +&#x3D; stepprint(&quot;original centroids: &quot;, centroid, &quot;\\n&quot;)class_i &#x3D; [[] for i in range(len(centroid))]class_text &#x3D; [[] for i in range(len(centroid))]# class_i is the null class for k centroidflag &#x3D; 1number &#x3D; 0times &#x3D; 0# sign if k never change or this program runs more than 100 timeswhile flag &#x3D;&#x3D; 1 and times &lt; 100: number +&#x3D; 1 flag &#x3D; 0 times +&#x3D; 1 class_i &#x3D; [[] for i in range(len(centroid))] class_text &#x3D; [[] for i in range(len(centroid))] # class_i is the null class for k centroid for i in range(0, len(new_ori_set)): distance &#x3D; float(&quot;inf&quot;) centroid_in_choose &#x3D; 0 for j in range(0, len(centroid)): if abs(new_ori_set[i] - centroid[j]) &lt; distance: distance &#x3D; abs(new_ori_set[i] - centroid[j]) centroid_in_choose &#x3D; j class_i[centroid_in_choose].append(new_ori_set[i]) class_text[centroid_in_choose].append(i) # sort all the elements into proper class # ------------ 每次 Clustering 之后的结果输出 ------------ # print(&quot;after %sth cluster: &quot; % number, &quot;\\n&quot;) # print(&quot;centroid class&quot;) # for i in range(0, len(class_i)): # print(centroid[i], &#39; &#39;, class_i[i]) # # print(&quot;---------&quot;) # ------------ 每次 Clustering 之后的结果输出 END ------------ for i in range(0, len(class_i)): sum &#x3D; 0 for j in range(0, len(class_i[i])): sum +&#x3D; class_i[i][j] if sum !&#x3D; 0: new_centroid &#x3D; round(sum &#x2F; len(class_i[i]), 3) else: continue if new_centroid !&#x3D; centroid[i]: # print(&quot;change centroid &quot;, centroid[i], &quot;as &quot;, end&#x3D;&quot;&quot;) centroid[i] &#x3D; new_centroid # print(centroid[i]) flag &#x3D; 1 # print(&quot;---------&quot;) # change the wrong centroid# ------------ Clustering 最终结果输出 -----------# print(&quot;THE CONCLUSION IS：&quot;)# print(&quot;centroid class&quot;)# for i in range(0, len(class_i)):# print(centroid[i], &#39; &#39;, [text[element] for element in class_text[i]])# ------------ Clustering 最终结果输出 END -----------# -------------- * UPPER IS CLUSTERING, CLUSTERING IS END.* --------------# ------------ 输出到txt -------------try: path &#x3D; &#39;out&#x2F;&#39; f &#x3D; open(path + &quot;result.txt&quot;, &quot;w+&quot;) f.write(&quot;cat\\ttitle\\n&quot;) for i in range(0, len(class_i)): for element in class_text[i]: f.write(str(i) + &quot;\\t&quot; + text[element] + &quot;\\n&quot;) f.close() print(&quot;Print out %d classes successfully.&quot;%k)except: print(&quot;Print out to txt ERROR.&quot;)# ------------ 输出到txt END -------------","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]},{"title":"Chinese Characters Clustering","slug":"simple-clustering","date":"2018-01-25T08:47:26.000Z","updated":"2020-04-05T02:57:13.105Z","comments":true,"path":"2018/01/25/simple-clustering/","link":"","permalink":"https://zqzhao.cn/2018/01/25/simple-clustering/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304# -*- coding: utf-8 -*-__author__ &#x3D; &#39;Zhao&#39;import reimport operatorblank &#x3D; [chr(183)]tabs &#x3D; [&#39;&#39;]def tree(lst): l &#x3D; len(lst) if l &#x3D;&#x3D; 0: print(&#39;─&#39; * 3) else: for i, j in enumerate(lst): if i !&#x3D; 0: print(tabs[0], end&#x3D;&#39;&#39;) if l &#x3D;&#x3D; 1: s &#x3D; &#39;─&#39; * 3 elif i &#x3D;&#x3D; 0: s &#x3D; &#39;┬&#39; + &#39;─&#39; * 2 elif i + 1 &#x3D;&#x3D; l: s &#x3D; &#39;└&#39; + &#39;─&#39; * 2 else: s &#x3D; &#39;├&#39; + &#39;─&#39; * 2 print(s, end&#x3D;&#39;&#39;) if isinstance(j, list) or isinstance(j, tuple): if i + 1 &#x3D;&#x3D; l: tabs[0] +&#x3D; blank[0] * 3 else: tabs[0] +&#x3D; &#39;│&#39; + blank[0] * 2 tree(j) else: print(&quot; &quot;, j) tabs[0] &#x3D; tabs[0][:-3]def judge_element_delete(list_input, centroid, group, match_num): for list_element in list_input: if isinstance(list_element, list): for element in list_element: if element &#x3D;&#x3D; match_num: del centroid[list_input.index(list_element)] del group[list_input.index(list_element)] else: if list_element &#x3D;&#x3D; match_num: del centroid[list_input.index(list_element)] del group[list_input.index(list_element)]# --------------- in this part we save the list as list ---------------path &#x3D; &#39;&#x2F;Users&#x2F;apple&#x2F;desktop&#x2F;&#39;fp &#x3D; open(path + &#39;list.txt&#39;)ori &#x3D; fp.readlines()# ori is the list with out any operationcopy &#x3D; []for x in ori: x &#x3D; re.sub(r&#39;\\n&#39;, &#39;&#39;, x) copy.append(x)# in this part we change the format in a into standard format and save as copyfp.close()# we close the file, then we can run the list totally in this programcopy.sort()# --------------- this part end ---------------# in this part we know the average length in this list is 2, thus we set step as 5.# In that case, we can contain at least one word.# totally, there are 56064 words in this list and only 56 is longer than 5.# In that case, 5 can be a reasonable step for this program.# sum &#x3D; 0# num &#x3D; 0# for x in copy:# sum +&#x3D; len(x)# num +&#x3D; 1# average &#x3D; (int)(sum&#x2F;num)# print(average, &#39; &#39;, num);# max_lenth &#x3D; 0# for x in copy:# if max_lenth &lt; len(x):# max_lenth &#x3D; len(x)## print(max_lenth)# number &#x3D; 0# for x in copy:# if len(x) &gt; 5:# number +&#x3D; 1## print(number)# --------------- the upper is the calculation in the preparation ---------------str_input &#x3D; input(&quot;请输入一个段落：\\n&quot;)str_input &#x3D; re.sub(r&#39;,&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;，&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;\\.&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;。&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;——&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;……&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;！&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;!&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;\\?&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;？&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;;&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39;；&#39;, &quot;&quot;, str_input)str_input &#x3D; re.sub(r&#39; &#39;, &quot;&quot;, str_input)# change all the punctuation as blank, however, we may split falsely.# Words get around, the step can also split at wrong place, so, I do not fix this mistake.str_head &#x3D; 0str_tail &#x3D; len(str_input)ptr &#x3D; 5temp &#x3D; 0step &#x3D; 5result &#x3D; []ch_index &#x3D; []while temp &lt; str_tail-1: flag &#x3D; 0 ptr &#x3D; 5 while flag !&#x3D; 1: in_put &#x3D; str_input[temp:temp + ptr] tail &#x3D; len(copy) head &#x3D; 0 half &#x3D; int((tail + head) &#x2F; 2) while tail !&#x3D; half and head !&#x3D; half: if operator.lt(copy[half], in_put): # 如果字符组的一半比input小 head &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) elif operator.gt(copy[half], in_put): # 如果字符组的一半比input大 tail &#x3D; half half &#x3D; int((tail + head) &#x2F; 2) else: # print(in_put, end&#x3D;&#39;&#x2F;&#39;) result.append(in_put) ch_index.append(half) flag &#x3D; 1 temp +&#x3D; len(in_put) break if ptr &#x3D;&#x3D; 0 and temp &lt;&#x3D; len(str_input)-1: # print(str_input[temp], end&#x3D;&#39;&#x2F;&#39;) result.append(str_input[temp]) ch_index.append(-1) temp +&#x3D; 1 flag &#x3D; 1 if flag &#x3D;&#x3D; 0: ptr -&#x3D; 1group &#x3D; resultcentroid &#x3D; ch_index# group &#x3D; input(&quot;Please input some numbers spit as blank:\\n&quot;).split(&quot; &quot;)# group_num &#x3D; len(group)# for element in group:# centroid.append(int(element))precision &#x3D; 0for element in group: precision &#x3D; len(element) if len(element) &gt; precision else precisiongroup_num &#x3D; len(group)while group_num !&#x3D; 2: # print(&quot;the numbers of groups now is &quot;, group_num, &quot;\\n&quot;) matrix &#x3D; [[] for i in range(group_num)] for i in range(group_num): for j in range(group_num): distance &#x3D; abs(int(centroid[i]) - int(centroid[j])) matrix[i].append(distance) # --------------- matrix --------------- # print(&quot;distance matrix :&quot;) # for i in range(group_num): # print(matrix[i]) # matrix contains the distance between every two elements # print(&quot;------------&quot;) max_in_matrix &#x3D; 0 for i in range(group_num): for j in range(group_num): max_in_matrix &#x3D; max_in_matrix if max_in_matrix &gt; matrix[i][j] else matrix[i][j] # print(max_in_matrix) # if max_in_matrix &#x3D;&#x3D; 0: # break for i in range(group_num): for j in range(group_num): matrix[i][j] &#x2F;&#x3D; max_in_matrix matrix[i][j] &#x3D; round(1 - matrix[i][j], precision) if round(1 - matrix[i][j], precision) !&#x3D; 1 else 0 # print(&quot;standard matrix :&quot;) # for i in range(group_num): # print(matrix[i]) # print(&quot;------------&quot;) # standard the matrix similarity &#x3D; 0 for i in range(group_num): for j in range(group_num): similarity &#x3D; similarity if similarity &gt; matrix[i][j] else matrix[i][j] # print(&quot;max similarity in the matrix: &quot;, max_in_matrix, &quot;\\n&quot;) # --------------- matrix --------------- # find the max similarity in this matrix temp_class &#x3D; [] index &#x3D; [] flag &#x3D; 0 for i in range(group_num): for j in range(group_num): if matrix[i][j] &#x3D;&#x3D; similarity: index.append(i) index.append(j) flag &#x3D; 1 temp_class.append(group[i]) temp_class.append(group[j]) if flag &#x3D;&#x3D; 1: break if flag &#x3D;&#x3D; 1: break # find the first center index of new group group_num &#x3D; len(group) for i in range(group_num): if matrix[index[0]][i] &#x3D;&#x3D; similarity and i !&#x3D; index[1]: temp_class.append(group[i]) index.append(i) for i in range(group_num): if matrix[index[1]][i] &#x3D;&#x3D; similarity and i !&#x3D; index[0]: temp_class.append(group[i]) index.append(i) new_centroid &#x3D; 0 for element in index: new_centroid +&#x3D; centroid[element] new_centroid &#x2F;&#x3D; len(index) for element in index: group[element] &#x3D; &#39;substitute&#39; centroid[element] &#x3D; &#39;substitute&#39; lenth &#x3D; len(group) temp_flag &#x3D; 0 while temp_flag !&#x3D; 1: temp_flag &#x3D; 1 for i in range(0, lenth): if group[i] &#x3D;&#x3D; &#39;substitute&#39;: del group[i] lenth &#x3D; len(group) temp_flag &#x3D; 0 break lenth &#x3D; len(centroid) temp_flag &#x3D; 0 while temp_flag !&#x3D; 1: temp_flag &#x3D; 1 for i in range(0, lenth): if centroid[i] &#x3D;&#x3D; &#39;substitute&#39;: del centroid[i] lenth &#x3D; len(centroid) temp_flag &#x3D; 0 break group.append(temp_class) centroid.append(new_centroid) group_num &#x3D; len(group)print(group)tree(group)","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]},{"title":"Python 3.5 Set-Up","slug":"python-setting","date":"2017-11-16T08:13:09.000Z","updated":"2020-04-05T04:10:19.867Z","comments":true,"path":"2017/11/16/python-setting/","link":"","permalink":"https://zqzhao.cn/2017/11/16/python-setting/","excerpt":"","text":"install Homebrew1&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot; Jump if already installed. It’s necessary to update your homebrew to the latest version. 2020-04-05 Update: If you get blocked, try to fix the problem by this. Use Homebrew install Python3 &amp; pip3 (pip is a package management tool for Python), automatically latest version, you may choose another version. 1$ brew install python3 We use pip3 because we want to use Python 3.x.x. If you need pip simply, try1$ sudo easy_install pip install pip need administrator role Check the version 1234$python --version$python3 --version$pip --version$pip3 --version Install [PyCharm](https://www.jetbrains.com/pycharm/). I recommend community edition. If you want the professional edition, there is a Free JetBrains Products License Server. Install additional packages: For example, bs4 (BeautifulSoup 4): PyCharm offer you an inner package management tool: Preferences —&gt; Project —&gt; Project Interpreter Click “+” to install packages you need. Usually there are some errors, follow its introduction and try again. At most cases, error occurs when you revoke the administrator role. So… sudoplease Another way is to install in the terminal: $ pip3 install bs4 if any problems, follow the introduction and try again. Usually you need to upgrade your “pip” “homebrew” “python” or other relative package.","categories":[{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[]}],"categories":[{"name":"Theory","slug":"Theory","permalink":"https://zqzhao.cn/categories/Theory/"},{"name":"Tech","slug":"Tech","permalink":"https://zqzhao.cn/categories/Tech/"}],"tags":[{"name":"Theorical_Basis","slug":"Theorical-Basis","permalink":"https://zqzhao.cn/tags/Theorical-Basis/"},{"name":"MIS_thinking","slug":"MIS-thinking","permalink":"https://zqzhao.cn/tags/MIS-thinking/"},{"name":"CS_Math","slug":"CS-Math","permalink":"https://zqzhao.cn/tags/CS-Math/"},{"name":"Clustering","slug":"Clustering","permalink":"https://zqzhao.cn/tags/Clustering/"}]}